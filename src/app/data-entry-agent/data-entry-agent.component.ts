import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';
import { DataEntryAgentService, ExtractedData } from '../services/data-entry-agent.service';

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  type: 'text' | 'loading' | 'progress' | 'dropdown' | 'contact-form';
  data?: any;
}

@Component({
  selector: 'app-data-entry-agent',
  templateUrl: './data-entry-agent.component.html',
  styleUrls: ['./data-entry-agent.component.scss']
})
export class DataEntryAgentComponent implements OnInit {
  messages: ChatMessage[] = [];
  newMessage = '';
  loading = false;
  
  // Document upload
  uploadedFiles: File[] = [];
  showDocumentModal = false;
  pendingFiles: File[] = [];
  documentMetadataForm!: FormGroup;
  
  // Contact form
  contactForm!: FormGroup;
  showContactForm = false;

  constructor(
    private agentService: DataEntryAgentService,
    private fb: FormBuilder
  ) {
    this.contactForm = this.fb.group({
      name: ['', Validators.required],
      jobTitle: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]],
      mobile: ['', Validators.required],
      landline: [''],
      preferredLanguage: ['Arabic']
    });
  }

  ngOnInit(): void {
    this.initializeChat();
  }

  private initializeChat(): void {
    // Add welcome message after a short delay to ensure user profile is loaded
    setTimeout(() => {
      this.addWelcomeMessage();
    }, 500);
  }

  private addWelcomeMessage(): void {
    const welcomeMessage: ChatMessage = {
      id: `welcome_${Date.now()}`,
      role: 'assistant',
      content: this.agentService.getWelcomeMessage(),
      timestamp: new Date(),
      type: 'text'
    };
    this.addMessage(welcomeMessage);
  }

  getCurrentUserName(): string {
    const user = this.agentService.getCurrentUser();
    return user?.fullName || 'Data Entry User';
  }

  onFileSelected(event: any): void {
    if (event.target && event.target.files && event.target.files.length > 0) {
      const files = Array.from(event.target.files) as File[];
      
      // Validate file types and sizes
      const validFiles = files.filter(file => {
        const isValidType = file.type.startsWith('image/') || file.type === 'application/pdf';
        const isValidSize = file.size <= 10 * 1024 * 1024; // 10MB
        
        if (!isValidType) {
          console.warn(`Invalid file type: ${file.name}`);
          return false;
        }
        
        if (!isValidSize) {
          console.warn(`File too large: ${file.name}`);
          return false;
        }
        
        return true;
      });
      
      if (validFiles.length > 0) {
        this.pendingFiles = validFiles;
        this.openDocumentModal();
      }
      
      // Clear the input
      event.target.value = '';
    } else {
      console.warn('No files selected or event.target.files is undefined');
    }
  }

  openDocumentModal(): void {
    this.showDocumentModal = true;
    
    // Initialize form
    this.documentMetadataForm = this.fb.group({
      documents: this.fb.array([])
    });

    // Add form group for each file
    this.pendingFiles.forEach((file, index) => {
      this.addDocumentFormGroup(file);
    });
  }

  private addDocumentFormGroup(file: File): void {
    const documentsFA = this.documentMetadataForm.get('documents') as FormArray;
    
    // Smart detection
    const detectedInfo = this.guessDocumentType(file.name);
    
    const documentGroup = this.fb.group({
      name: [file.name],
      country: [detectedInfo?.country || ''],
      type: [detectedInfo?.type || ''],
      description: [this.generateSmartDescription(file.name, detectedInfo)]
    });
    
    documentsFA.push(documentGroup);
  }

  private guessDocumentType(filename: string): { country: string; type: string } | null {
    const lowerName = filename.toLowerCase();
    
    // Country detection
    let country = '';
    if (lowerName.includes('egypt') || lowerName.includes('cairo') || lowerName.includes('ŸÖÿµÿ±')) {
      country = 'Egypt';
    } else if (lowerName.includes('uae') || lowerName.includes('dubai') || lowerName.includes('ÿßŸÑÿ•ŸÖÿßÿ±ÿßÿ™')) {
      country = 'United Arab Emirates';
    } else if (lowerName.includes('saudi') || lowerName.includes('riyadh') || lowerName.includes('ÿßŸÑÿ≥ÿπŸàÿØŸäÿ©')) {
      country = 'Saudi Arabia';
    } else if (lowerName.includes('yemen') || lowerName.includes('ÿßŸÑŸäŸÖŸÜ')) {
      country = 'Yemen';
    }
    
    // Document type detection
    let type = '';
    if (lowerName.includes('commercial') || lowerName.includes('registration') || lowerName.includes('ÿ™ÿ¨ÿßÿ±Ÿä')) {
      type = 'Commercial Registration';
    } else if (lowerName.includes('tax') || lowerName.includes('ÿ∂ÿ±Ÿäÿ®Ÿä')) {
      type = 'Tax Card';
    } else if (lowerName.includes('license') || lowerName.includes('ÿ±ÿÆÿµÿ©')) {
      type = 'Business License';
    }
    
    return country && type ? { country, type } : null;
  }

  private generateSmartDescription(filename: string, detectedInfo: any): string {
    let description = `Document: ${filename}`;
    if (detectedInfo?.country) {
      description += ` (${detectedInfo.country})`;
    }
    if (detectedInfo?.type) {
      description += ` - ${detectedInfo.type}`;
    }
    return description;
  }

  closeDocumentModal(): void {
    this.showDocumentModal = false;
    this.pendingFiles = [];
    this.documentMetadataForm.reset();
  }

  get documentsFA(): FormArray {
    return this.documentMetadataForm.get('documents') as FormArray;
  }

  get allDocumentTypes(): string[] {
    return [
      'Commercial Registration',
      'Tax Card',
      'Business License',
      'Trade License',
      'Tax Certificate'
    ];
  }

  saveDocuments(): void {
    if (this.documentMetadataForm.valid) {
      const filesToProcess = [...this.pendingFiles];
      this.closeDocumentModal();
      
      // Get metadata from form
      const metadata = this.documentsFA.controls.map(control => ({
        country: control.get('country')?.value,
        type: control.get('type')?.value,
        description: control.get('description')?.value
      }));

      this.processDocumentsWithMetadata(filesToProcess, metadata);
    }
  }

  private async processDocumentsWithMetadata(files: File[], metadata: Array<{ country?: string; type: string; description: string }>): Promise<void> {
    try {
      // Add user message about uploaded files
      const fileNames = files.map(f => f.name).join(', ');
      this.addMessage({
        id: `upload_${Date.now()}`,
        role: 'user',
        content: `üì§ ÿ™ŸÖ ÿ±ŸÅÿπ ${files.length} ŸÖÿ≥ÿ™ŸÜÿØ: ${fileNames}`,
        timestamp: new Date(),
        type: 'text'
      });

      // Show document details
      files.forEach((file, index) => {
        const meta = metadata[index];
        this.addMessage({
          id: `doc_${Date.now()}_${index}`,
          role: 'assistant',
          content: `üìÑ ${file.name} (${meta.type}) - ${meta.description}`,
          timestamp: new Date(),
          type: 'text'
        });
      });

      // Show loading message
      const progressMessage = this.addMessage({
        id: `progress_${Date.now()}`,
        role: 'assistant',
        content: 'üîÑ ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™...',
        timestamp: new Date(),
        type: 'loading'
      });

      // Process documents with timeout
      await Promise.race([
        this.agentService.uploadAndProcessDocuments(files, metadata),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Document processing timeout')), 60000))
      ]);

      // Remove loading message
      this.messages = this.messages.filter(m => m.id !== progressMessage.id);

      // Display extracted data
      const extractedData = this.agentService.getExtractedData();
      this.displayExtractedDataWithLabels(extractedData);

      // Check for missing fields
      const missingFields = this.checkMissingFields(extractedData);
      if (missingFields.length > 0) {
        this.askForMissingField(missingFields[0]);
      } else {
        this.addMessage({
          id: `complete_${Date.now()}`,
          role: 'assistant',
          content: '‚úÖ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÉÿ™ŸÖŸÑÿ©!\n\nüîç ÿ≥ÿ£ÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿ¢ŸÜ ŸÖŸÜ ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ ÿ™ŸÉÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ...',
          timestamp: new Date(),
          type: 'text'
        });
      }

    } catch (error: any) {
      console.error('Error processing documents:', error);
      
      // Remove loading message
      this.messages = this.messages.filter(m => m.type !== 'loading');
      
      this.addMessage({
        id: `error_${Date.now()}`,
        role: 'assistant',
        content: `‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™:\n\nÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ: ${error.message}`,
        timestamp: new Date(),
        type: 'text'
      });
    }
  }

  private checkMissingFields(data: any): string[] {
    const requiredFields = [
      'firstName', 'firstNameAR', 'tax', 'CustomerType', 'ownerName',
      'buildingNumber', 'street', 'country', 'city',
      'salesOrganization', 'distributionChannel', 'division', 'contacts'
    ];
    
    return requiredFields.filter(field => {
      if (field === 'contacts') {
        return !data[field] || data[field].length === 0;
      }
      return !data[field] || data[field].trim() === '';
    });
  }

  private askForMissingField(field: string): void {
    const fieldLabel = this.getFieldLabel(field);
    
    if (this.isDropdownField(field)) {
      this.askForDropdownSelection(field, fieldLabel);
    } else if (field === 'contacts') {
      this.askForContactForm();
    } else {
      this.addMessage({
        id: `missing_${Date.now()}`,
        role: 'assistant',
        content: `‚ö†Ô∏è ÿ®ÿπÿ∂ ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÜÿßŸÇÿµÿ©:\n\n‚Ä¢ ${fieldLabel}\n\nÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÜÿßŸÇÿµÿ©.`,
        timestamp: new Date(),
        type: 'text'
      });
    }
  }

  private isDropdownField(field: string): boolean {
    const dropdownFields = ['salesOrganization', 'distributionChannel', 'division', 'CustomerType'];
    return dropdownFields.includes(field);
  }

  private askForDropdownSelection(field: string, fieldLabel: string): void {
    const options = this.getDropdownOptions(field);
    
    this.addMessage({
      id: `dropdown_${Date.now()}`,
      role: 'assistant',
      content: `üìã Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ${fieldLabel}:`,
      timestamp: new Date(),
      type: 'dropdown',
      data: {
        field: field,
        label: fieldLabel,
        options: options
      }
    });
  }

  private getDropdownOptions(field: string): string[] {
    const options: { [key: string]: string[] } = {
      'salesOrganization': ['egypt_cairo_office', 'uae_dubai_office', 'saudi_riyadh_office', 'yemen_main_office'],
      'distributionChannel': ['direct_sales', 'retail_chains', 'wholesale', 'online'],
      'division': ['food_products', 'beverages', 'household_items', 'personal_care'],
      'CustomerType': ['Corporate', 'Individual']
    };
    return options[field] || [];
  }

  private askForContactForm(): void {
    this.addMessage({
      id: `contact_form_${Date.now()}`,
      role: 'assistant',
      content: 'üë• Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ¨Ÿáÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ:\n\nŸäŸÖŸÉŸÜŸÉ ÿ•ÿ∂ÿßŸÅÿ© ÿπÿØÿ© ÿ¨Ÿáÿßÿ™ ÿßÿ™ÿµÿßŸÑ ŸÇÿ®ŸÑ ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ©.',
      timestamp: new Date(),
      type: 'contact-form'
    });
  }

  onDropdownSelection(field: string, value: string): void {
    this.agentService.updateExtractedDataField(field, value);
    
    this.addMessage({
      id: `selected_${Date.now()}`,
      role: 'user',
      content: `‚úÖ ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ±: ${value}`,
      timestamp: new Date(),
      type: 'text'
    });

    // Check for next missing field
    const extractedData = this.agentService.getExtractedData();
    const missingFields = this.checkMissingFields(extractedData);
    
    if (missingFields.length > 0) {
      this.askForMissingField(missingFields[0]);
    } else {
      this.addMessage({
        id: `complete_${Date.now()}`,
        role: 'assistant',
        content: '‚úÖ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÉÿ™ŸÖŸÑÿ©!\n\nüîç ÿ≥ÿ£ÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿ¢ŸÜ ŸÖŸÜ ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ ÿ™ŸÉÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ...',
        timestamp: new Date(),
        type: 'text'
      });
    }
  }

  openContactForm(): void {
    this.showContactForm = true;
  }

  closeContactForm(): void {
    this.showContactForm = false;
  }

  saveContactForm(): void {
    if (this.contactForm.valid) {
      const contactData = this.contactForm.value;
      const currentData = this.agentService.getExtractedData();
      currentData.contacts = currentData.contacts || [];
      currentData.contacts.push(contactData);
      this.agentService.updateExtractedDataField('contacts', currentData.contacts);
      
      this.contactForm.reset();
      
      this.addMessage({
        id: `contact_saved_${Date.now()}`,
        role: 'assistant',
        content: `‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿ¨Ÿáÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ: ${contactData.name}\n\nŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿ¨Ÿáÿ© ÿßÿ™ÿµÿßŸÑ ÿ£ÿÆÿ±Ÿâÿü`,
        timestamp: new Date(),
        type: 'text'
      });
    }
  }

  continueWithoutMoreContacts(): void {
    this.closeContactForm();
    
    // Check for next missing field
    const extractedData = this.agentService.getExtractedData();
    const missingFields = this.checkMissingFields(extractedData);
    
    if (missingFields.length > 0) {
      this.askForMissingField(missingFields[0]);
    } else {
      this.addMessage({
        id: `complete_${Date.now()}`,
        role: 'assistant',
        content: '‚úÖ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÉÿ™ŸÖŸÑÿ©!\n\nüîç ÿ≥ÿ£ÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿ¢ŸÜ ŸÖŸÜ ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ ÿ™ŸÉÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ...',
        timestamp: new Date(),
        type: 'text'
      });
    }
  }

  private getFieldLabel(field: string): string {
    const labels: { [key: string]: string } = {
      'firstName': 'ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© / Company Name (EN)',
      'firstNameAR': 'ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© / Company Name (AR)',
      'tax': 'ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑÿ∂ÿ±Ÿäÿ®Ÿä / Tax Number',
      'CustomerType': 'ŸÜŸàÿπ ÿßŸÑÿπŸÖŸäŸÑ / Customer Type',
      'ownerName': 'ÿßÿ≥ŸÖ ŸÖÿßŸÑŸÉ ÿßŸÑÿ¥ÿ±ŸÉÿ© / Company Owner Name',
      'buildingNumber': 'ÿ±ŸÇŸÖ ÿßŸÑŸÖÿ®ŸÜŸâ / Building Number',
      'street': 'ÿßŸÑÿ¥ÿßÿ±ÿπ / Street',
      'country': 'ÿßŸÑÿØŸàŸÑÿ© / Country',
      'city': 'ÿßŸÑŸÖÿØŸäŸÜÿ© / City',
      'salesOrganization': 'ÿßŸÑŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ®ŸäÿπŸäÿ© / Sales Organization',
      'distributionChannel': 'ŸÇŸÜÿßÿ© ÿßŸÑÿ™Ÿàÿ≤Ÿäÿπ / Distribution Channel',
      'division': 'ÿßŸÑŸÇÿ≥ŸÖ / Division',
      'contacts': 'ÿ¨Ÿáÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ / Contacts'
    };
    return labels[field] || field;
  }

  private displayExtractedDataWithLabels(data: ExtractedData): void {
    let content = 'üìã ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿ±ÿ¨ÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™:\n\n';
    
    // Company info
    content += 'üè¢ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ÿ±ŸÉÿ©:\n';
    if (data.firstName) content += `‚úì ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© / Company Name (EN): ${data.firstName}\n`;
    if (data.firstNameAR) content += `‚úì ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© / Company Name (AR): ${data.firstNameAR}\n`;
    if (data.tax) content += `‚úì ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑÿ∂ÿ±Ÿäÿ®Ÿä / Tax Number: ${data.tax}\n`;
    if (data.CustomerType) content += `‚úì ŸÜŸàÿπ ÿßŸÑÿπŸÖŸäŸÑ / Customer Type: ${data.CustomerType}\n`;
    if (data.ownerName) content += `‚úì ÿßÿ≥ŸÖ ŸÖÿßŸÑŸÉ ÿßŸÑÿ¥ÿ±ŸÉÿ© / Company Owner Name: ${data.ownerName}\n`;
    
    // Address info
    content += '\nüìç ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿπŸÜŸàÿßŸÜ:\n';
    if (data.buildingNumber) content += `‚úì ÿ±ŸÇŸÖ ÿßŸÑŸÖÿ®ŸÜŸâ / Building Number: ${data.buildingNumber}\n`;
    if (data.street) content += `‚úì ÿßŸÑÿ¥ÿßÿ±ÿπ / Street: ${data.street}\n`;
    if (data.country) content += `‚úì ÿßŸÑÿØŸàŸÑÿ© / Country: ${data.country}\n`;
    if (data.city) content += `‚úì ÿßŸÑŸÖÿØŸäŸÜÿ© / City: ${data.city}\n`;
    
    // Sales area
    content += '\nüíº ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™:\n';
    if (data.salesOrganization) content += `‚úì ÿßŸÑŸÖŸÜÿ∏ŸÖÿ© ÿßŸÑÿ®ŸäÿπŸäÿ© / Sales Organization: ${data.salesOrganization}\n`;
    if (data.distributionChannel) content += `‚úì ŸÇŸÜÿßÿ© ÿßŸÑÿ™Ÿàÿ≤Ÿäÿπ / Distribution Channel: ${data.distributionChannel}\n`;
    if (data.division) content += `‚úì ÿßŸÑŸÇÿ≥ŸÖ / Division: ${data.division}\n`;
    
    // Contacts
    if (data.contacts && data.contacts.length > 0) {
      content += '\nüë• ÿ¨Ÿáÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ:\n\n';
      data.contacts.forEach((contact, index) => {
        content += `ÿ¨Ÿáÿ© ÿßÿ™ÿµÿßŸÑ ${index + 1}:\n`;
        content += `‚Ä¢ ÿßŸÑÿßÿ≥ŸÖ: ${contact.name}\n`;
        content += `‚Ä¢ ÿßŸÑŸÖÿ≥ŸÖŸâ ÿßŸÑŸàÿ∏ŸäŸÅŸä: ${contact.jobTitle}\n`;
        content += `‚Ä¢ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä: ${contact.email}\n`;
        content += `‚Ä¢ ÿßŸÑÿ¨ŸàÿßŸÑ: ${contact.mobile}\n`;
        if (contact.landline) content += `‚Ä¢ ÿßŸÑŸáÿßÿ™ŸÅ ÿßŸÑÿ£ÿ±ÿ∂Ÿä: ${contact.landline}\n`;
        content += '\n';
      });
    }
    
    content += '---\nüí° ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ£Ÿä ŸÖÿπŸÑŸàŸÖÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©ÿå ŸäŸÖŸÉŸÜŸÉ ÿ•ÿÆÿ®ÿßÿ±Ÿä ÿ®ÿßŸÑÿµÿ≠Ÿäÿ≠ Ÿàÿ≥ÿ£ŸÇŸàŸÖ ÿ®ÿ™ÿπÿØŸäŸÑŸáÿß.\nŸÖÿ´ÿßŸÑ: "ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ ŸáŸà ABC Company" ÿ£Ÿà "ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑÿ∂ÿ±Ÿäÿ®Ÿä ÿÆÿ∑ÿ£ÿå ÿßŸÑÿµÿ≠Ÿäÿ≠ 123456"';
    
    this.addMessage({
      id: `extracted_${Date.now()}`,
      role: 'assistant',
      content: content,
      timestamp: new Date(),
      type: 'text'
    });
  }

  async sendMessage(message?: string): Promise<void> {
    const userMessage = message || this.newMessage.trim();
    if (!userMessage) return;

    // Add user message
    this.addMessage({
      id: `user_${Date.now()}`,
      role: 'user',
      content: userMessage,
      timestamp: new Date(),
      type: 'text'
    });

    this.newMessage = '';
    this.loading = true;

    try {
      // Check if this is a response to a missing field
      const lastMessage = this.messages[this.messages.length - 2];
      const isMissingFieldResponse = lastMessage && 
        lastMessage.role === 'assistant' && 
        lastMessage.content.includes('Company Owner Name');

      if (isMissingFieldResponse) {
        // Direct field update
        this.agentService.updateExtractedDataField('ownerName', userMessage);
        
        this.addMessage({
          id: `confirmed_${Date.now()}`,
          role: 'assistant',
          content: `‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßÿ≥ŸÖ ŸÖÿßŸÑŸÉ ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿ•ŸÑŸâ: ${userMessage}`,
          timestamp: new Date(),
          type: 'text'
        });

        // Check for next missing field
        const extractedData = this.agentService.getExtractedData();
        const missingFields = this.checkMissingFields(extractedData);
        
        if (missingFields.length > 0) {
          this.askForMissingField(missingFields[0]);
        } else {
          this.addMessage({
            id: `complete_${Date.now()}`,
            role: 'assistant',
            content: '‚úÖ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÉÿ™ŸÖŸÑÿ©!\n\nüîç ÿ≥ÿ£ÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿ¢ŸÜ ŸÖŸÜ ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ ÿ™ŸÉÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ...',
            timestamp: new Date(),
            type: 'text'
          });
        }
      } else {
        // Use AI for general responses
        const loadingMessage = this.addMessage({
          id: `loading_${Date.now()}`,
          role: 'assistant',
          content: 'üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...',
          timestamp: new Date(),
          type: 'loading'
        });

        try {
          const aiResponse = await Promise.race([
            this.agentService.sendMessage(userMessage),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), 30000))
          ]) as any;

          // Remove loading message
          this.messages = this.messages.filter(m => m.id !== loadingMessage.id);

          this.addMessage({
            id: `ai_${Date.now()}`,
            role: 'assistant',
            content: aiResponse,
            timestamp: new Date(),
            type: 'text'
          });
        } catch (error: any) {
          // Remove loading message
          this.messages = this.messages.filter(m => m.id !== loadingMessage.id);
          
          this.addMessage({
            id: `error_${Date.now()}`,
            role: 'assistant',
            content: 'ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßŸÑÿ™ŸÉ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.\nSorry, there was an error processing your message. Please try again.',
            timestamp: new Date(),
            type: 'text'
          });
        }
      }
    } catch (error: any) {
      console.error('Error in sendMessage:', error);
      this.addMessage({
        id: `error_${Date.now()}`,
        role: 'assistant',
        content: 'ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßŸÑÿ™ŸÉ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.\nSorry, there was an error processing your message. Please try again.',
        timestamp: new Date(),
        type: 'text'
      });
    } finally {
      this.loading = false;
    }
  }

  onEnterKey(event: KeyboardEvent): void {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      this.sendMessage();
    }
  }

  removeDocument(index: number): void {
    this.uploadedFiles.splice(index, 1);
    this.agentService.removeDocument(`doc_${index}`);
  }

  getUploadedDocuments(): Array<{id: string, name: string, type: string, size: number, content: string}> {
    return this.agentService.getDocuments();
  }

  formatMessage(content: string): string {
    return content.replace(/\n/g, '<br>');
  }

  private addMessage(message: ChatMessage): ChatMessage {
    this.messages.push(message);
    
    // Limit message history to prevent memory leaks
    if (this.messages.length > 50) {
      this.messages = this.messages.slice(-30); // Keep last 30 messages
    }
    
    setTimeout(() => this.scrollToBottom(), 100);
    return message;
  }

  private scrollToBottom(): void {
    const chatBody = document.querySelector('.chat-body');
    if (chatBody) {
      chatBody.scrollTop = chatBody.scrollHeight;
    }
  }
}
