import { Location, isPlatformBrowser } from '@angular/common';
import { Router, ActivatedRoute } from '@angular/router';
import { Component, Inject, PLATFORM_ID, ViewEncapsulation, OnInit } from '@angular/core';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../environments/environment';

import {
  FormBuilder,
  FormGroup,
  Validators,
  FormArray
} from '@angular/forms';

import { TranslateService } from '@ngx-translate/core';
import { NzI18nService, en_US } from 'ng-zorro-antd/i18n';
import { NzNotificationService } from 'ng-zorro-antd/notification';
import { NzMessageService } from 'ng-zorro-antd/message';
import { NzUploadFile } from 'ng-zorro-antd/upload';
import { Observable, firstValueFrom } from 'rxjs';
import { DemoDataGeneratorService, DemoCompany } from '../services/demo-data-generator.service';
import { AutoTranslateService } from '../services/auto-translate.service';

// Import unified lookup data
import {
  CUSTOMER_TYPE_OPTIONS,
  SALES_ORG_OPTIONS,
  DISTRIBUTION_CHANNEL_OPTIONS,
  DIVISION_OPTIONS,
  CITY_OPTIONS,
  COUNTRY_OPTIONS,
  PREFERRED_LANGUAGE_OPTIONS,
  DOCUMENT_TYPE_OPTIONS,
  getCitiesByCountry
} from '../shared/lookup-data';

type DocType = 'Commercial Registration' | 'Tax Certificate' | 'License' | 'Other';

interface UploadedDoc {
  id: string;
  name: string;
  type: DocType;
  description: string;
  size: number;
  mime: string;
  uploadedAt: string;
  contentBase64: string;
  source?: 'SAP S/4HANA' | 'SAP ByD' | 'Oracle Forms' | 'Data Steward';
  by?: string;
  when?: string;
}

interface ContactPerson {
  id: string;
  name: string;
  jobTitle?: string;
  email?: string;
  mobile?: string;
  landline?: string;
  preferredLanguage?: string;
  source?: 'SAP S/4HANA' | 'SAP ByD' | 'Oracle Forms' | 'Data Steward';
  by?: string;
  when?: string;
}

interface TaskRecord {
  id: number | string;
  requestId?: string;
  firstName?: string;
  firstNameAr?: string;
  street?: string;
  buildingNumber?: string;
  city?: string;
  country?: string;
  tax?: string;
  ContactName?: string;
  JobTitle?: string;
  EmailAddress?: string;
  MobileNumber?: string;
  Landline?: string;
  PrefferedLanguage?: string;
  SalesOrgOption?: string;
  DistributionChannelOption?: string;
  DivisionOption?: string;
  CustomerType?: string;
  CompanyOwner?: string;
  IssueDescription?: string;
  status?: string;
  ComplianceStatus?: string;
  blockReason?: string;
  rejectReason?: string;
  origin?: 'dataEntry' | 'quarantine' | 'duplicates' | 'compliance' | 'goldenEdit' | 'unknown';
  sourceSystem?: 'SAP S/4HANA' | 'SAP ByD' | 'Oracle Forms' | 'Data Steward';
  contacts?: ContactPerson[];
  documents?: UploadedDoc[];
  issues?: any[];
  createdBy?: string;
  assignedTo?: string;
  sourceGoldenId?: string;
  notes?: string;
  requestType?: string;
  originalRequestType?: string;
}

interface CurrentUser {
  id?: string;
  username: string;
  role?: string;
}

@Component({
  selector: 'app-new-request',
  templateUrl: './new-request.component.html',
  styleUrls: ['./new-request.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class NewRequestComponent implements OnInit {
  // CRITICAL: Prevent multiple initializations to avoid infinite loops
  private isInitialized = false;
  requestForm!: FormGroup;
  private apiBase = environment.apiBaseUrl || 'http://localhost:3000/api';
  
  // Current user info - NO localStorage dependency
  currentUser: CurrentUser | null = null;
  userRole: 'data_entry' | 'reviewer' | 'compliance' | 'admin' | null = null;
  userType: string | null = null; // For template compatibility: '1'=data_entry, '2'=reviewer, '3'=compliance
  private currentUserRole: string | null = null;
  
  // Page modes
  canEdit = false;
  canView = false;
  canApproveReject = false;
  canComplianceAction = false;
  editPressed = false;
  hasRecord = false;
  isNewRequest = false;
  isLoading = false;

  // Golden Edit mode - مُحدث ومُحسن
  isGoldenEditMode = false;
  isEditingGoldenRecord = false;
  sourceGoldenRecordId: string | null = null;

  // Quarantine mode flag
  isFromQuarantine = false;
  isQuarantineRecord = false; // NEW: Track if this is a quarantine record

  status = 'Pending';
  isArabic = false;

  // UI state
  isApprovedVisible = false;
  approvedChecked = true;
  isRejectedVisible = false;
  rejectedChecked = true;
  isRejectedConfirmVisible = false;
  isAssignVisible = false;
  selectedDepartment: any;

  // Compliance popup
  isBlockModalVisible = false;
  blockReason = '';

  stateIssues: any[] = [];
  showSummary = false;

  filteredCityOptions: any[] = [];
  private previousCountry: string | null = null;
  private suppressCityReset = false;

  // Reject modal
  rejectComment = '';

  // Document upload
  isMetaModalOpen = false;
  pendingFile?: File;
  maxSizeMB = 10;
  allowedTypes = [
    'application/pdf',
    'image/jpeg',
    'image/png',
    'image/webp',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'text/plain'
  ];

  docTypeOptions = DOCUMENT_TYPE_OPTIONS.map(option => ({
    ...option,
    label: option.value === 'Other' ? this.translate.instant('Other') : option.label
  }));

  metaForm = this.fb.group({
    type: ['Other'],
    description: ['']
  });

  // Use unified lookup data from shared constants
  CustomerTypeOptions = CUSTOMER_TYPE_OPTIONS;
  SalesOrgOption = SALES_ORG_OPTIONS;
  DistributionChannelOption = DISTRIBUTION_CHANNEL_OPTIONS;
  DivisionOption = DIVISION_OPTIONS;
  CityOptions = CITY_OPTIONS;
  CountryOptions = COUNTRY_OPTIONS;
  PrefferedLanguage = PREFERRED_LANGUAGE_OPTIONS;

  private originalRecord: TaskRecord | null = null;
  private currentRecordId: string | null = null;

  // ====== Upload Document Modal ======
  showUploadModal = false;
  newDocument: any = {
    name: '',
    type: '',
    description: '',
    file: null
  };

  // ====== Document Preview & Download ======
  showDocumentPreviewModal = false;
  selectedDocument: any = null;

  // Getters
  get documentsFA(): FormArray { return this.requestForm.get('documents') as FormArray; }
  get documentsFGs(): FormGroup[] { return this.documentsFA.controls as FormGroup[]; }
  get contactsFA(): FormArray { return this.requestForm.get('contacts') as FormArray; }
  get contactsFGs(): FormGroup[] { return this.contactsFA.controls as FormGroup[]; }

  get statusClassMap() {
    const s = String(this.status);
    return {
      'is-approved': s === 'Approved',
      'is-pending': s === 'Pending',
      'is-rejected': s === 'Rejected',
      'is-updated': s === 'Updated',
      'is-quarantined': s === 'Quarantined' || s === 'Quarantine'
    };
  }

  constructor(
    private fb: FormBuilder,
    private i18n: NzI18nService,
    private route: ActivatedRoute,
    private notification: NzNotificationService,
    private translate: TranslateService,
    public router: Router,
    private location: Location,
    private msg: NzMessageService,
    @Inject(PLATFORM_ID) private platformId: Object,
    private http: HttpClient,
    private demoDataGenerator: DemoDataGeneratorService,
    private autoTranslate: AutoTranslateService,
    private sanitizer: DomSanitizer
  ) {}

  async ngOnInit(): Promise<void> {
    // CRITICAL: Prevent multiple initializations to avoid infinite loops
    if (this.isInitialized) {
      console.warn('Component already initialized, skipping...');
      return;
    }
    this.isInitialized = true;
    
    try {
      console.log('=== NEW REQUEST COMPONENT INIT ===');
      console.log('Route params:', this.route.snapshot.paramMap);
      console.log('Query params:', this.route.snapshot.queryParams);
      
      this.i18n.setLocale(en_US);
      this.initForm();
      this.setupCountryCityLogic();
      
      // Get current user
      await this.getCurrentUser();
      
      // Determine role from route
      this.determineRoleFromRoute();
      
      // Check for special modes
      const mode = this.route.snapshot.queryParamMap.get('mode');
      const from = this.route.snapshot.queryParamMap.get('from');
      const fromQuarantine = this.route.snapshot.queryParamMap.get('fromQuarantine');
      
      if (fromQuarantine === 'true') {
        console.log('=== QUARANTINE MODE DETECTED ===');
        this.isFromQuarantine = true;
        this.userRole = 'data_entry';
        this.userType = '1';
        this.currentUserRole = 'data_entry';
      }
      
      if (mode === 'edit-golden' && from === 'golden-summary') {
        console.log('=== GOLDEN EDIT MODE DETECTED ===');
        this.isGoldenEditMode = true;
        this.isEditingGoldenRecord = true;
        await this.loadGoldenRecordForEditing();
      } else {
        // Load regular request data
        await this.loadRequestData();
      }

      // Language setting
      if (isPlatformBrowser(this.platformId)) {
        this.isArabic = false;
      }

      // CRITICAL FIX: Setup watchers AFTER loading data to avoid loops
      setTimeout(() => {
        // Duplicate warning - with debounce
        let duplicateCheckTimeout: any;
        this.requestForm.get('firstName')?.valueChanges.subscribe(() => {
          clearTimeout(duplicateCheckTimeout);
          duplicateCheckTimeout = setTimeout(() => this.checkForDuplicates(), 500);
        });
        
        this.requestForm.get('tax')?.valueChanges.subscribe(() => {
          clearTimeout(duplicateCheckTimeout);
          duplicateCheckTimeout = setTimeout(() => this.checkForDuplicates(), 500);
        });
        
        // Auto-translation - with check to avoid loops
        let isTranslating = false;
        this.requestForm.get('firstName')?.valueChanges.subscribe((value) => {
          if (!isTranslating && value && this.autoTranslate.needsTranslation(value)) {
            isTranslating = true;
            this.onEnglishNameChange(value);
            setTimeout(() => { isTranslating = false; }, 100);
          }
        });
      }, 1000);
      
    } catch (error) {
      console.error('Error in ngOnInit:', error);
      this.isLoading = false;
      this.msg.error('Error initializing page');
    }
  }

  // ENHANCED: Load golden record for editing
  private async loadGoldenRecordForEditing(): Promise<void> {
    console.log('Loading golden record for editing...');
    
    // Get data from router state
    const routerState = history.state;
    console.log('Router state:', routerState);
    
    if (routerState && routerState['goldenRecord']) {
      const goldenRecord = routerState.goldenRecord;
      const contacts = routerState.contacts || [];
      const documents = routerState.documents || [];
      const sourceGoldenId = routerState.sourceGoldenId;
      
      // Store source golden record ID for later use
      this.sourceGoldenRecordId = sourceGoldenId || goldenRecord.id;
      
      console.log('Golden record data received:', goldenRecord);
      console.log('Source Golden ID:', this.sourceGoldenRecordId);
      
      // Set form state for editing
      this.isNewRequest = false;
      this.hasRecord = true;
      this.editPressed = true;
      this.canEdit = true;
      this.status = 'Pending'; // New request based on golden record
      
      // Pre-populate the form with golden record data
      this.suppressCityReset = true;
      
      this.requestForm.patchValue({
        firstName: goldenRecord.name || '',
        firstNameAR: goldenRecord.nameAr || '',
        tax: goldenRecord.taxNumber || '',
        buildingNumber: goldenRecord.buildingNumber || '',
        street: goldenRecord.streetName || '',
        country: goldenRecord.country || '',
        city: goldenRecord.city || '',
        ContactName: goldenRecord.contactName || '',
        JobTitle: goldenRecord.jobTitle || '',
        EmailAddress: goldenRecord.email || '',
        MobileNumber: goldenRecord.phone || '',
        Landline: goldenRecord.landline || '',
        PrefferedLanguage: goldenRecord.preferredLanguage || '',
        SalesOrgOption: goldenRecord.salesOrg || '',
        DistributionChannelOption: goldenRecord.distributionChannel || '',
        DivisionOption: goldenRecord.division || '',
        CustomerType: goldenRecord.recordType || 'Corporate',
        CompanyOwnerFullName: goldenRecord.companyOwnerName || ''
      });
      
      // Setup city options based on country
      const selectedCountry = goldenRecord.country;
      if (selectedCountry) {
        // Use helper function from shared constants
        this.filteredCityOptions = getCitiesByCountry(selectedCountry);
      }
      
      // Load contacts with new IDs to avoid conflicts
      this.contactsFA.clear();
      if (contacts && contacts.length > 0) {
        contacts.forEach((c: any) => {
          this.contactsFA.push(this.fb.group({
            id: [this.uid()], // Generate new ID to avoid conflicts
            name: [c.name || '', Validators.required],
            jobTitle: [c.jobTitle || ''],
            email: [c.email || ''],
            mobile: [c.mobile || ''],
            landline: [c.landline || ''],
            preferredLanguage: [c.preferredLanguage || '']
          }));
        });
      }
      
      // Load documents with new IDs to avoid conflicts
      this.documentsFA.clear();
      if (documents && documents.length > 0) {
        documents.forEach((d: any) => {
          this.documentsFA.push(this.fb.group({
            id: [this.uid()], // Generate new ID to avoid conflicts
            name: [d.name || ''],
            type: [d.type || 'Other'],
            description: [d.description || ''],
            size: [d.size || 0],
            mime: [d.mime || ''],
            uploadedAt: [new Date().toISOString()], // New timestamp
            contentBase64: [d.contentBase64 || '']
          }));
        });
      }
      
      // Store reference to source golden record for submission
      this.originalRecord = {
        sourceGoldenId: this.sourceGoldenRecordId,
        origin: 'goldenEdit',
        notes: `Created by editing Golden Record: ${goldenRecord.goldenCode || this.sourceGoldenRecordId}`
      } as TaskRecord;
      
      this.suppressCityReset = false;
      
      // Enable form for editing
      this.requestForm.enable();
      
      // Add contact if none exist
      if (this.contactsFA.length === 0) {
        this.addContact();
      }
      
      console.log('Golden record form populated successfully');
      this.msg.success('Golden record data loaded successfully. You can now edit and resubmit.');
      
    } else {
      console.error('No golden record data found in router state');
      this.msg.error('No golden record data received. Please try again.');
      // Redirect back to golden requests
      setTimeout(() => {
        this.router.navigate(['/dashboard/golden-requests']);
      }, 3000);
    }
  }

  private async getCurrentUser(): Promise<void> {
    try {
      console.log('=== GET CURRENT USER START ===');
      
      // Check multiple storage locations for username
      const username = sessionStorage.getItem('username') || 
                      localStorage.getItem('username') || 
                      localStorage.getItem('user');
      
      console.log('New Request - Getting user with username:', username);
      
      if (!username) {
        console.error('No username found in storage');
        this.currentUser = { username: 'data_entry', role: 'data_entry' };
        this.mapUserRole('data_entry');
        console.log('=== GET CURRENT USER END (no username) ===');
        return;
      }
      
      const url = `${this.apiBase}/auth/me?username=${username}`;
      
      try {
        console.log('Making API call to:', url);
        const userResponse = await Promise.race([
          firstValueFrom(this.http.get<any>(url)),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 3000)
          )
        ]);
        const user = userResponse as any;
        
        console.log('User API response:', user);
        if (user && (user.username || user.id)) {
          this.currentUser = {
            username: user.username || username,
            role: user.role || 'data_entry',
            id: user.id
          };
          this.mapUserRole(user.role || 'data_entry');
          console.log('Current user loaded:', this.currentUser);
        } else {
          console.warn('Invalid user response, using fallback');
          this.currentUser = { username: username, role: 'data_entry' };
          this.mapUserRole('data_entry');
        }
        console.log('=== GET CURRENT USER SUCCESS ===');
      } catch (apiError) {
        console.error('API call failed, using fallback user data');
        this.currentUser = {
          username: username,
          role: username === 'data_entry' ? 'data_entry' : 
                username === 'reviewer' ? 'reviewer' : 
                username === 'compliance' ? 'compliance' : 'data_entry'
        };
        this.mapUserRole(this.currentUser.role || 'data_entry');
      }
      
    } catch (error) {
      console.error('Error in getCurrentUser:', error);
      this.currentUser = { username: 'data_entry', role: 'data_entry' };
      this.mapUserRole('data_entry');
    }
    
    console.log('=== GET CURRENT USER END ===');
    console.log('Final user state:', {
      currentUser: this.currentUser,
      userRole: this.userRole,
      userType: this.userType
    });
  }

  private mapUserRole(apiRole: string): void {
    // Fix role mapping - handle the database inconsistency
    let correctedRole = apiRole;
    
    // Get username for verification
    const username = this.currentUser?.username;
    
    // Check query params first (from navigation)
    const queryRole = this.route.snapshot.queryParams['userRole'];
    if (queryRole) {
      correctedRole = queryRole;
      console.log('Using role from query params:', queryRole);
    } else {
      // Fix based on username
      if (username === 'data_entry' && apiRole !== 'data_entry' && apiRole !== '1') {
        console.log('Fixing role for data_entry user');
        correctedRole = 'data_entry';
      }
      
      if (username === 'reviewer' && apiRole !== 'reviewer' && apiRole !== '2') {
        console.log('Fixing role for reviewer user');
        correctedRole = 'reviewer';
      }
      
      if (username === 'compliance' && apiRole !== 'compliance' && apiRole !== '3') {
        console.log('Fixing role for compliance user');
        correctedRole = 'compliance';
      }
    }
    
    // Map corrected roles to component roles
    if (correctedRole === 'reviewer' || correctedRole === 'master' || correctedRole === '2') {
      this.userRole = 'reviewer';
      this.userType = '2';
      this.currentUserRole = 'reviewer';
    } else if (correctedRole === 'data_entry' || correctedRole === '1') {
      this.userRole = 'data_entry';
      this.userType = '1';
      this.currentUserRole = 'data_entry';
    } else if (correctedRole === 'compliance' || correctedRole === '3') {
      this.userRole = 'compliance';
      this.userType = '3';
      this.currentUserRole = 'compliance';
    } else if (correctedRole === 'admin' || correctedRole === 'demo-admin') {
      this.userRole = 'admin';
      this.userType = 'admin';
      this.currentUserRole = 'admin';
    }
    
    console.log('User role mapped:', {
      originalApiRole: apiRole,
      correctedRole: correctedRole,
      userRole: this.userRole,
      userType: this.userType,
      queryRole: queryRole
    });
  }

  private determineRoleFromRoute(): void {
    const queryParams = this.route.snapshot.queryParams;
    
    console.log('Determining role from route:', queryParams);
    
    // Use query params from navigation
    if (queryParams['userRole']) {
      this.mapUserRole(queryParams['userRole']);
    } else if (queryParams['from']) {
      // Determine from where user came
      switch(queryParams['from']) {
        case 'reviewer-tasks':
        case 'my-task-list':
        case 'admin-task-list':
          // If action is review, user is reviewer
          if (queryParams['action'] === 'review') {
            this.userRole = 'reviewer';
            this.userType = '2';
            this.currentUserRole = 'reviewer';
          } else if (queryParams['action'] === 'edit') {
            this.userRole = 'data_entry';
            this.userType = '1';
            this.currentUserRole = 'data_entry';
          }
          break;
        case 'compliance-task-list':
        case 'compliance-tasks':
          this.userRole = 'compliance';
          this.userType = '3';
          this.currentUserRole = 'compliance';
          break;
        case 'data-entry-tasks':
        case 'golden-summary': // Add golden-summary case
          this.userRole = 'data_entry';
          this.userType = '1';
          this.currentUserRole = 'data_entry';
          break;
      }
    } else {
      // Final fallback based on status
      const status = queryParams['status'];
      if (status === 'Approved') {
        this.userRole = 'compliance';
        this.userType = '3';
        this.currentUserRole = 'compliance';
      } else if (status === 'Pending') {
        this.userRole = 'reviewer';
        this.userType = '2';
        this.currentUserRole = 'reviewer';
      } else if (status === 'Rejected') {
        this.userRole = 'data_entry';
        this.userType = '1';
        this.currentUserRole = 'data_entry';
      }
    }
    
    console.log('Role determined from route:', {
      userRole: this.userRole,
      userType: this.userType
    });
  }

  private initForm(): void {
    this.requestForm = this.fb.group({
      firstName: [null, Validators.required],
      firstNameAR: [null, Validators.required],
      street: [null],
      city: [null, Validators.required],
      country: [null, Validators.required],
      tax: [null, Validators.required],
      ContactName: [null],
      EmailAddress: [null],
      MobileNumber: [null],
      JobTitle: [null],
      Landline: [null],
      PrefferedLanguage: [null],
      SalesOrgOption: [null],
      DistributionChannelOption: [null],
      DivisionOption: [null],
      buildingNumber: [null],
      CustomerType: [null],
      CompanyOwnerFullName: [null],
      ComplianceStatus: [null],
      contacts: this.fb.array([]),
      documents: this.fb.array([])
    });
  }

  private setupCountryCityLogic(): void {
    this.previousCountry = this.requestForm.get('country')?.value || null;
    
    // Add flag to prevent loops
    let isUpdatingCity = false;
    
    this.requestForm.get('country')?.valueChanges.subscribe(selectedCountry => {
      if (isUpdatingCity) return; // Prevent recursion
      
      // Use helper function from shared constants
      this.filteredCityOptions = getCitiesByCountry(selectedCountry || '');

      if (this.suppressCityReset) {
        this.previousCountry = selectedCountry;
        return;
      }
      
      const currentCity = this.requestForm.get('city')?.value;
      const cityStillValid = this.filteredCityOptions.some(o => o.value === currentCity);
      if ((this.editPressed || this.isNewRequest || this.isGoldenEditMode) && !cityStillValid) {
        isUpdatingCity = true;
        this.requestForm.get('city')?.setValue(null, { emitEvent: false }); // Don't trigger events
        setTimeout(() => { isUpdatingCity = false; }, 100);
      }
      this.previousCountry = selectedCountry;
    });
  }

  private async loadRequestData(): Promise<void> {
    const routeId = this.route.snapshot.paramMap.get('id');
    const queryParams = this.route.snapshot.queryParams;
    
    console.log('=== LOAD REQUEST DATA ===');
    console.log('Route ID:', routeId);
    console.log('Query params:', queryParams);
    console.log('Current user role:', this.userRole);
    console.log('Current user type:', this.userType);
    
    // Clean up ID if it has REQ- prefix
    const cleanId = routeId?.replace('REQ-', '');
    console.log('Clean ID:', cleanId);
    
    // Check if this is coming from reviewer
    if (queryParams['userRole'] === 'reviewer' && queryParams['action'] === 'review') {
      console.log('Reviewer mode detected from query params');
      this.userRole = 'reviewer';
      this.userType = '2';
      this.currentUserRole = 'reviewer';
    }
    
    // CRITICAL FIX: Handle the case where ID exists but needs loading
    if (cleanId && cleanId !== 'new') {
      // Load existing record from API
      this.isLoading = true;
      console.log('Loading request data for ID:', cleanId, 'Query params:', queryParams);
      try {
        const apiUrl = `${this.apiBase}/requests/${cleanId}`;
        console.log('Making API call to:', apiUrl);
        const record = await Promise.race([
          firstValueFrom(this.http.get<TaskRecord>(apiUrl)),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 10000)
          )
        ]) as TaskRecord;
        console.log('API response received:', record);
        console.log('Record type:', typeof record);
        console.log('Record keys:', record ? Object.keys(record) : 'No record');
        
        if (record && record.id) {
          this.currentRecordId = cleanId; // CRITICAL: Store the ID for updates
          this.originalRecord = record;
          this.hasRecord = true;
          this.status = record.status || 'Pending';
          
          // Check if this is a Quarantine record
          if (this.isFromQuarantine || record.status === 'Quarantine' || record.status === 'Quarantined') {
            console.log('Handling Quarantine record with ID:', cleanId);
            this.isQuarantineRecord = true;
            this.canEdit = true;
            this.canView = false;
            this.canApproveReject = false;
            this.canComplianceAction = false;
            this.editPressed = true;
            this.requestForm.enable();
          } else {
            // Set permissions based on API data
            this.setPermissionsFromRecord(record);
            
            // Set form state based on permissions
            if (this.canEdit) {
              // Data entry can edit
              this.requestForm.enable();
              this.editPressed = true;
            } else {
              // Reviewer, Compliance, and view-only modes
              this.requestForm.disable();
              this.editPressed = false;
              
              // For reviewer/compliance, ensure they can still interact with documents
              if (this.canApproveReject || this.canComplianceAction) {
                console.log('Form disabled for review/compliance mode');
              }
            }
          }
          
          // Patch form with record data
          this.patchFromRecord(record);
          
          console.log('Record loaded with permissions:', {
            id: cleanId,
            currentRecordId: this.currentRecordId,
            status: this.status,
            userRole: this.userRole,
            userType: this.userType,
            canApproveReject: this.canApproveReject,
            canComplianceAction: this.canComplianceAction,
            canEdit: this.canEdit,
            isFromQuarantine: this.isFromQuarantine,
            isQuarantineRecord: this.isQuarantineRecord,
            assignedTo: record.assignedTo,
            requestType: record.requestType,
            originalRequestType: record.originalRequestType
          });
        } else {
          console.error('No valid record received from API!');
          this.msg.error('Invalid record data received');
          
          // Set basic reviewer permissions anyway
          if (queryParams['userRole'] === 'reviewer') {
            this.userRole = 'reviewer';
            this.userType = '2';
            this.canView = true;
            this.canApproveReject = false; // Cannot approve without data
            this.canEdit = false;
            this.requestForm.disable();
          }
        }
      } catch (error: any) {
        console.error('Error loading request:', {
          error: error,
          message: error?.message,
          status: error?.status,
          url: error?.url,
          cleanId: cleanId,
          apiBase: this.apiBase
        });
        
        // Set fallback permissions for reviewer
        if (queryParams['userRole'] === 'reviewer') {
          console.log('Setting fallback reviewer permissions');
          this.userRole = 'reviewer';
          this.userType = '2';
          this.canView = true;
          this.canApproveReject = true;
          this.canEdit = false;
          this.requestForm.disable();
          this.editPressed = false;
        }
        
        if (error?.status === 404) {
          this.msg.error('Request not found');
        } else if (error?.status === 0) {
          this.msg.error('Cannot connect to server. Please check if the API server is running.');
        } else if (error?.name === 'TimeoutError') {
          this.msg.error('Request timed out. Please try again.');
        } else {
          this.msg.error(`Failed to load request data: ${error?.message || 'Unknown error'}`);
        }
      } finally {
        this.isLoading = false;
      }
    } else if (!cleanId || cleanId === 'new') {
      // New request mode
      this.isNewRequest = true;
      this.editPressed = true;
      this.requestForm.enable();
      // For new requests, default to data entry role if not set
      if (!this.userRole) {
        this.userRole = 'data_entry';
        this.userType = '1';
        this.currentUserRole = 'data_entry';
      }
      if (this.contactsFA.length === 0) {
        this.addContact();
      }
    }
  }

  // FIXED: Handle permissions for quarantine rejected records
  private setPermissionsFromRecord(record: TaskRecord): void {
    // Reset permissions
    this.canEdit = false;
    this.canApproveReject = false;
    this.canComplianceAction = false;
    this.canView = false;

    console.log('Setting permissions from record:', {
      userRole: this.userRole,
      currentUserRole: this.currentUserRole,
      recordStatus: record.status,
      assignedTo: record.assignedTo,
      ComplianceStatus: record.ComplianceStatus,
      requestType: record.requestType,
      originalRequestType: record.originalRequestType
    });

    // Use the role determined from API or route
    const effectiveRole = this.userRole || this.currentUserRole;

    // FIXED: Check if this is a quarantine rejected record
    const isQuarantineRejected = (record.requestType === 'quarantine' || 
                                   record.originalRequestType === 'quarantine') &&
                                  record.status === 'Rejected';

    switch (effectiveRole) {
      case 'data_entry':
        // Check for multiple assignedTo values including system_import
        const isAssignedToDataEntry = record.assignedTo === 'data_entry' || 
                                       record.assignedTo === 'system_import' ||
                                       !record.assignedTo;
        
        // Can edit rejected requests (including quarantine rejected)
        this.canEdit = (record.status === 'Rejected' && (isAssignedToDataEntry || isQuarantineRejected)) ||
                      record.status === 'Quarantine' || 
                      record.status === 'Quarantined';
        this.canView = !this.canEdit;
        break;
        
      case 'reviewer':
        // FIXED: Reviewer should be able to review pending requests
        this.canApproveReject = record.status === 'Pending' && 
                               (record.assignedTo === 'reviewer' || !record.assignedTo);
        this.canView = true; // Reviewer can always view
        this.canEdit = false; // Reviewer cannot edit
        
        // CRITICAL: Ensure userType is set for template
        this.userType = '2';
        
        // CRITICAL: Disable the form for reviewer but keep it viewable
        if (this.canApproveReject) {
          this.requestForm.disable();
          this.editPressed = false; // Make sure edit mode is off
        }
        break;
        
      case 'compliance':
        // Can approve/block approved requests assigned to compliance
        this.canComplianceAction = record.status === 'Approved' && 
                                  record.assignedTo === 'compliance' && 
                                  (!record.ComplianceStatus || record.ComplianceStatus === '');
        this.canView = true; // Compliance can always view
        this.canEdit = false; // Compliance cannot edit
        
        // Ensure userType is set for template
        this.userType = '3';
        
        // Disable form for compliance
        if (this.canComplianceAction) {
          this.requestForm.disable();
          this.editPressed = false;
        }
        break;
        
      case 'admin':
        // Admin can do everything based on status
        this.canEdit = ['Rejected', 'Pending', 'Quarantine', 'Quarantined'].includes(record.status || '');
        this.canApproveReject = record.status === 'Pending';
        this.canComplianceAction = record.status === 'Approved' && 
                                  (!record.ComplianceStatus || record.ComplianceStatus === '');
        this.canView = true;
        this.userType = 'admin';
        break;
        
      default:
        // Default to view only
        this.canView = true;
        break;
    }

    console.log('Permissions set:', {
      canEdit: this.canEdit,
      canApproveReject: this.canApproveReject,
      canComplianceAction: this.canComplianceAction,
      canView: this.canView,
      effectiveRole: effectiveRole,
      userType: this.userType,
      isQuarantineRejected: isQuarantineRejected
    });
  }

  // Compliance actions
  async submitBlock(): Promise<void> {
    const id = this.currentRecordId;
    const reason = (this.blockReason || '').trim();

    if (!id || !reason) {
      this.msg.warning('Please enter a block reason.');
      return;
    }

    try {
      await firstValueFrom(
        this.http.post(`${this.apiBase}/requests/${id}/compliance/block`, { reason })
      );
      
      this.isBlockModalVisible = false;
      this.blockReason = '';

      this.notification.success('Master record created as Blocked Golden Record!', '');
      this.router.navigate(['/dashboard/compliance-task-list']);
    } catch (error) {
      console.error('Error blocking request:', error);
      this.notification.error('Error blocking record. Please try again.', '');
    }
  }

  async onComplianceApprove(): Promise<void> {
    const id = this.currentRecordId;
    if (!id) return;

    try {
      await firstValueFrom(
        this.http.post(`${this.apiBase}/requests/${id}/compliance/approve`, { 
          note: 'Approved as Golden Record' 
        })
      );

      this.notification.success('Master record approved as Active Golden Record successfully!', '');
      this.router.navigate(['/dashboard/compliance-task-list']);
    } catch (error) {
      console.error('Error approving request:', error);
      this.notification.error('Error approving record. Please try again.', '');
    }
  }

  // FIXED: Submit form - handle quarantine records properly with UPDATE
  async onSubmit(): Promise<void> {
    console.log('=== FORM SUBMISSION START ===');
    console.log('Form valid:', this.requestForm.valid);
    console.log('Current Record ID:', this.currentRecordId);
    console.log('Golden Edit Mode:', this.isGoldenEditMode);
    console.log('From Quarantine:', this.isFromQuarantine);
    console.log('Is Quarantine Record:', this.isQuarantineRecord);
    console.log('Status:', this.status);
    console.log('Source Golden ID:', this.sourceGoldenRecordId);
    console.log('Current User:', this.currentUser);
    
    if (!this.requestForm.valid) {
      console.log('Form validation failed');
      Object.values(this.requestForm.controls).forEach(ctrl => {
        (ctrl as any).markAsDirty?.();
        (ctrl as any).updateValueAndValidity?.({ onlySelf: true });
      });
      this.msg.warning('Please fill all required fields');
      return;
    }

    const payload = this.buildPayloadFromForm();
    console.log('Payload built:', payload);
    
    this.isLoading = true;

    try {
      // CRITICAL: Check if we have an existing record ID for UPDATE
      if (this.currentRecordId && !this.isGoldenEditMode) {
        // UPDATE existing record - includes Quarantine, Rejected, etc.
        console.log('UPDATING existing request with ID:', this.currentRecordId);
        
        await firstValueFrom(
          this.http.put(`${this.apiBase}/requests/${this.currentRecordId}`, payload)
        );
        
        // If this is a Quarantine record, call complete-quarantine endpoint
        if (this.isQuarantineRecord || this.status === 'Quarantine' || this.status === 'Quarantined' || this.isFromQuarantine) {
          console.log('Completing quarantine record...');
          try {
            await firstValueFrom(
              this.http.post(`${this.apiBase}/requests/${this.currentRecordId}/complete-quarantine`, {})
            );
            console.log('Quarantine record marked as complete');
          } catch (error) {
            console.error('Error completing quarantine:', error);
            // Continue even if this fails - the update was successful
          }
        }
        
        const message = this.isQuarantineRecord || this.status === 'Quarantine' || this.status === 'Quarantined'
          ? await firstValueFrom(this.translate.get('Quarantine record completed and submitted for review'))
          : this.status === 'Rejected'
          ? await firstValueFrom(this.translate.get('Rejected request updated and resubmitted for review'))
          : await firstValueFrom(this.translate.get('Request updated successfully'));
        
        this.notification.success(message, '');
        
      } else if (this.isGoldenEditMode) {
        // GOLDEN EDIT MODE: Create new request with Golden Edit logic
        console.log('=== SUBMITTING GOLDEN EDIT REQUEST ===');
        console.log('Creating new request for golden edit');
        
        const response = await firstValueFrom(
          this.http.post<any>(`${this.apiBase}/requests`, payload)
        );
        
        console.log('Golden Edit API Response:', response);
        this.currentRecordId = response.id;
        
        const message = await firstValueFrom(
          this.translate.get('Golden record changes submitted successfully! The original Golden Record has been temporarily suspended while your changes are being reviewed.')
        );
        this.notification.success(message, '');
        
      } else {
        // CREATE new request only if no currentRecordId
        console.log('Creating NEW request');
        const response = await firstValueFrom(
          this.http.post<any>(`${this.apiBase}/requests`, payload)
        );
        
        console.log('New request created:', response);
        this.currentRecordId = response.id;
        
        const message = await firstValueFrom(
          this.translate.get('New request created successfully')
        );
        this.notification.success(message, '');
      }
      
      // Navigate based on context
      console.log('Navigating to task list...');
      
      // If from Quarantine, go back to Quarantine page
      if (this.isFromQuarantine) {
        this.router.navigate(['/dashboard/quarantine']);
      } else {
        this.navigateToTaskList();
      }
    } catch (error) {
      console.error('Error submitting request:', error);
      this.msg.error('Failed to submit request');
    } finally {
      this.isLoading = false;
    }
  }

  private navigateToTaskList(): void {
    // Navigate based on current user role
    switch (this.userRole || this.currentUserRole) {
      case 'data_entry':
        this.router.navigate(['/dashboard/my-task']);
        break;
      case 'reviewer':
        this.router.navigate(['/dashboard/admin-task-list']);
        break;
      case 'compliance':
        this.router.navigate(['/dashboard/compliance-task-list']);
        break;
      case 'admin':
        this.router.navigate(['/dashboard/admin-task-list']);
        break;
      default:
        this.router.navigate(['/dashboard']);
    }
  }

  // ENHANCED: Build payload with golden edit support
  private buildPayloadFromForm() {
    const v = this.requestForm.getRawValue() as any;
    const payload: any = {
      firstName: v.firstName,
      firstNameAr: v.firstNameAR,
      tax: v.tax,
      buildingNumber: v.buildingNumber,
      street: v.street,
      country: v.country,
      city: v.city,
      CustomerType: v.CustomerType,
      CompanyOwner: v.CompanyOwnerFullName,
      SalesOrgOption: v.SalesOrgOption,
      DistributionChannelOption: v.DistributionChannelOption,
      DivisionOption: v.DivisionOption,
      ContactName: v.ContactName,
      EmailAddress: v.EmailAddress,
      MobileNumber: v.MobileNumber,
      JobTitle: v.JobTitle,
      Landline: v.Landline,
      PrefferedLanguage: v.PrefferedLanguage,
      contacts: (this.contactsFGs || []).map(g => g.value as ContactPerson),
      documents: (this.documentsFGs || []).map((g: any) => g.value as UploadedDoc),
      origin: this.originalRecord?.origin || 'dataEntry',
      sourceSystem: this.originalRecord?.sourceSystem || 'Data Steward',
      createdBy: this.currentUser?.username || 'data_entry',
      status: 'Pending',
      assignedTo: 'reviewer'
    };

    // Add update tracking fields when updating existing records
    if (this.currentRecordId && !this.isGoldenEditMode) {
      payload.updatedBy = this.currentUser?.username || 'data_entry';
      payload.updatedByRole = this.userRole || 'data_entry';
      payload.updateReason = 'User update';
    }

    // Add golden edit specific fields
    if (this.isGoldenEditMode && this.sourceGoldenRecordId) {
      payload.origin = 'goldenEdit';
      payload.sourceGoldenId = this.sourceGoldenRecordId;
      payload.notes = this.originalRecord?.notes || `Created by editing Golden Record: ${this.sourceGoldenRecordId}`;
      
      console.log('Golden Edit payload enhanced:', {
        origin: payload.origin,
        sourceGoldenId: payload.sourceGoldenId,
        notes: payload.notes
      });
    }

    // Handle Quarantine records - but don't override if updating
    if ((this.status === 'Quarantine' || this.status === 'Quarantined' || this.isFromQuarantine) && !this.currentRecordId) {
      payload.origin = 'quarantine';
      payload.notes = 'Completed from Quarantine';
    }

    return payload;
  }

  private patchFromRecord(rec: TaskRecord): void {
    console.log('=== PATCH FROM RECORD ===');
    console.log('Record to patch:', rec);
    
    if (!rec) {
      console.error('No record provided to patch!');
      return;
    }
    
    this.suppressCityReset = true;
    this.status = rec.status || 'Pending';

    // CRITICAL: Use emitEvent: false to prevent loops
    this.requestForm.patchValue({
      firstName: rec.firstName,
      firstNameAR: rec.firstNameAr,
      street: rec.street,
      buildingNumber: rec.buildingNumber,
      city: rec.city,
      country: rec.country,
      tax: rec.tax,
      ContactName: rec.ContactName,
      JobTitle: rec.JobTitle,
      EmailAddress: rec.EmailAddress,
      MobileNumber: rec.MobileNumber,
      Landline: rec.Landline,
      PrefferedLanguage: rec.PrefferedLanguage,
      SalesOrgOption: rec.SalesOrgOption,
      DistributionChannelOption: rec.DistributionChannelOption,
      DivisionOption: rec.DivisionOption,
      CustomerType: rec.CustomerType,
      CompanyOwnerFullName: rec.CompanyOwner,
      ComplianceStatus: rec.ComplianceStatus
    }, { emitEvent: false }); // CRITICAL: Don't trigger value changes

    // Setup city options based on country using helper function
    const selectedCountry = rec.country;
    if (selectedCountry) {
      this.filteredCityOptions = getCitiesByCountry(selectedCountry);
    }

    // Load contacts
    this.contactsFA.clear();
    if (Array.isArray(rec.contacts)) {
      rec.contacts.forEach((c: any) => {
        this.contactsFA.push(this.fb.group({
          id: [c.id || this.uid()],
          name: [c.name, Validators.required],
          jobTitle: [c.jobTitle],
          email: [c.email],
          mobile: [c.mobile],
          landline: [c.landline],
          preferredLanguage: [c.preferredLanguage]
        }), { emitEvent: false });
      });
    }

    // Load documents
    this.documentsFA.clear();
    if (Array.isArray(rec.documents)) {
      rec.documents.forEach((d: any) => {
        this.documentsFA.push(this.fb.group(d), { emitEvent: false });
      });
    }

    // Show summary for rejected/quarantined
    if (rec.rejectReason || rec.issues?.length) {
      this.stateIssues = rec.issues || [{ 
        description: rec.rejectReason || rec.blockReason || 'Issue found' 
      }];
      this.showSummary = true;
    }
    
    console.log('=== PATCH COMPLETED ===');
    console.log('Form values after patch:', this.requestForm.value);
    console.log('Contacts loaded:', this.contactsFA.length);
    console.log('Documents loaded:', this.documentsFA.length);
    console.log('Form disabled status:', this.requestForm.disabled);

    this.suppressCityReset = false;
  }

  // ENHANCED: Page title and submit button text with golden edit support
  getPageTitle(): string {
    if (this.isGoldenEditMode) {
      return 'Edit Golden Record';
    } else if (this.status === 'Quarantine' || this.status === 'Quarantined') {
      return 'Complete Quarantine Record';
    } else if (this.hasRecord && !this.isNewRequest) {
      return 'Edit Request';
    }
    return 'New Request';
  }

  getSubmitButtonText(): string {
    if (this.isGoldenEditMode) {
      return 'Update & Resubmit Golden Record';
    } else if (this.status === 'Quarantine' || this.status === 'Quarantined') {
      return 'Complete & Submit for Review';
    } else if (this.hasRecord && !this.isNewRequest) {
      return 'Update Request';
    }
    return 'Submit Request';
  }

  // Reviewer actions
  async submitApprove(): Promise<void> {
    const id = this.currentRecordId;
    if (!id) {
      this.msg.warning('No request ID found');
      this.closeAllModals();
      return;
    }

    this.isLoading = true;
    try {
      await firstValueFrom(
        this.http.post(`${this.apiBase}/requests/${id}/approve`, { 
          note: 'Approved by reviewer' 
        })
      );

      this.notification.success('Request approved and sent to compliance!', '');
      this.navigateToTaskList();
    } catch (error) {
      console.error('Error approving request:', error);
      this.notification.error('Error approving request. Please try again.', '');
    } finally {
      this.isLoading = false;
      this.closeAllModals();
    }
  }

  async submitReject(): Promise<void> {
    const id = this.currentRecordId;
    if (!id) {
      this.msg.warning('No request ID found');
      this.closeAllModals();
      return;
    }

    const reason = this.rejectComment?.trim() || 'Rejected by reviewer';

    this.isLoading = true;
    try {
      await firstValueFrom(
        this.http.post(`${this.apiBase}/requests/${id}/reject`, { reason })
      );

      this.notification.success('Request rejected and returned to data entry', '');
      this.navigateToTaskList();
    } catch (error) {
      console.error('Error rejecting request:', error);
      this.notification.error('Error rejecting record. Please try again.', '');
    } finally {
      this.isLoading = false;
      this.closeAllModals();
    }
  }

  // Helper methods
  private uid(): string {
    return 'id_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
  }

  addContact(): void {
    this.contactsFA.push(this.fb.group({
      id: [this.uid()],
      name: [null, Validators.required],
      jobTitle: [null],
      email: [null],
      mobile: [null],
      landline: [null],
      preferredLanguage: [null]
    }));
  }

  removeContact(i: number): void {
    this.contactsFA.removeAt(i);
  }

  // ENHANCED: Go back method with golden edit support
  goBack(): void {
    if (this.isGoldenEditMode) {
      // Go back to golden requests if editing golden record
      this.router.navigate(['/dashboard/golden-requests']);
    } else if (this.isFromQuarantine) {
      // Go back to quarantine if from quarantine
      this.router.navigate(['/dashboard/quarantine']);
    } else {
      this.location.back();
    }
  }

  // FIXED: Edit button now handles quarantine rejected records
  editRequest(): void {
    // Check if this is a quarantine rejected record
    const isQuarantineRejected = (this.originalRecord?.requestType === 'quarantine' || 
                                  this.originalRecord?.originalRequestType === 'quarantine') &&
                                 this.status === 'Rejected';
    
    // Check if user can edit based on role and record status
    if (this.canEdit || this.userRole === 'admin' || 
        this.status === 'Quarantine' || this.status === 'Quarantined' ||
        isQuarantineRejected) {
      this.editPressed = true;
      this.requestForm.enable();
      this.canEdit = true;
      console.log('Edit enabled for record:', {
        recordId: this.currentRecordId,
        status: this.status,
        isQuarantineRejected: isQuarantineRejected,
        userRole: this.userRole
      });
    } else {
      this.msg.warning('You do not have permission to edit this request');
    }
  }

  // Document handling
  private toBase64(file: File): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(String(reader.result));
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  beforeUpload = (file: File): boolean => {
    if (!this.allowedTypes.includes(file.type)) {
      this.msg.error('Unsupported file type');
      return false;
    }
    if (file.size > this.maxSizeMB * 1024 * 1024) {
      this.msg.error(`Max size ${this.maxSizeMB}MB`);
      return false;
    }
    this.pendingFile = file;
    this.metaForm.reset({ type: 'Other', description: '' });
    this.isMetaModalOpen = true;
    return false;
  };

  beforeUploadNz = (file: NzUploadFile): boolean => {
    const real = (file as any)?.originFileObj || file;
    return this.beforeUpload(real as File);
  };

  async confirmMeta(): Promise<void> {
    if (!this.pendingFile) return;
    
    const base64 = await this.toBase64(this.pendingFile);
    const doc: UploadedDoc = {
      id: this.uid(),
      name: this.pendingFile.name,
      type: (this.metaForm.value.type as DocType) || 'Other',
      description: this.metaForm.value.description || '',
      size: this.pendingFile.size,
      mime: this.pendingFile.type,
      uploadedAt: new Date().toISOString(),
      contentBase64: base64
    };
    
    this.documentsFA.push(this.fb.group(doc));
    this.isMetaModalOpen = false;
    this.pendingFile = undefined;
    this.msg.success('Document added');
  }

  removeDoc(index: number): void {
    this.documentsFA.removeAt(index);
  }

  getDocIcon(mime?: string): string {
    const m = (mime || '').toLowerCase();
    if (m.includes('pdf')) return 'file-pdf';
    if (m.includes('image')) return 'file-image';
    if (m.includes('word')) return 'file-text';
    if (m.includes('excel')) return 'file-text';
    return 'file';
  }

  getTypeColor(type?: string): string {
    switch ((type || '').toLowerCase()) {
      case 'commercial registration': return 'gold';
      case 'tax certificate': return 'geekblue';
      case 'license': return 'green';
      default: return 'default';
    }
  }

  // Duplicate checking
  duplicateCheckList = [
    { firstName: 'Unilever', tax: 'EG123' },
    { firstName: 'Nestle Egypt', tax: 'EG23456789012345' }
  ];
  showDuplicateWarning = false;
  duplicateName = '';
  duplicateTax = '';

  checkForDuplicates(): void {
    const normalize = (val: string) => (val || '').trim().toLowerCase();
    const firstName = normalize(this.requestForm.get('firstName')?.value);
    const tax = normalize(this.requestForm.get('tax')?.value);
    
    const isDuplicate = this.duplicateCheckList.some(
      r => normalize(r.firstName) === firstName && normalize(r.tax) === tax
    );
    
    this.showDuplicateWarning = isDuplicate;
    this.duplicateName = isDuplicate ? (this.requestForm.get('firstName')?.value || '') : '';
    this.duplicateTax = isDuplicate ? (this.requestForm.get('tax')?.value || '') : '';
  }

  // Modal controls
  closeAllModals(): void {
    this.isApprovedVisible = false;
    this.isRejectedVisible = false;
    this.isRejectedConfirmVisible = false;
    this.isAssignVisible = false;
    this.isBlockModalVisible = false;
  }

  stopPropagation(event: Event): void {
    event.stopPropagation();
  }

  showApproveModal(): void { 
    if (this.canApproveReject || this.userRole === 'admin') {
      this.submitApprove();
    } else {
      this.msg.warning('You do not have permission to approve this request');
    }
  }
  
  showRejectedModal(): void { 
    if (this.canApproveReject || this.userRole === 'admin') {
      this.isRejectedVisible = true;
    } else {
      this.msg.warning('You do not have permission to reject this request');
    }
  }

  showBlockModal(): void {
    if (this.canComplianceAction || this.userRole === 'admin') {
      this.isBlockModalVisible = true;
    } else {
      this.msg.warning('You do not have permission to block this request');
    }
  }
  
  showAssignModal(): void { 
    this.isAssignVisible = true; 
  }

  assignToBtn(): void {
    this.closeAllModals();
    this.msg.success('Assigned successfully');
    this.location.back();
  }

  // ====== Demo Data Generator ======
  
  /**
   * Fills the form with demo data from a real company
   * Perfect for demonstrations and testing
   */
  fillWithDemoData(): void {
    try {
      const demoCompany = this.demoDataGenerator.generateDemoData();
      
      // Show loading animation
      this.msg.loading('Generating demo data...', { nzDuration: 1000 });
      
      // Fill general data
      this.requestForm.patchValue({
        firstName: demoCompany.name,
        firstNameAr: demoCompany.nameAr,
        customerType: demoCompany.customerType,
        CompanyOwnerFullName: demoCompany.ownerName,
        tax: demoCompany.taxNumber,
        buildingNumber: demoCompany.buildingNumber,
        street: demoCompany.street,
        country: demoCompany.country,
        city: demoCompany.city,
        salesOrg: demoCompany.salesOrg,
        distributionChannel: demoCompany.distributionChannel,
        division: demoCompany.division
      });

      // Clear existing contacts and add demo contacts
      this.clearAllContacts();
      demoCompany.contacts.forEach(contact => {
        this.addContact();
        const lastIndex = this.contactsFA.length - 1;
        this.contactsFA.at(lastIndex).patchValue({
          name: contact.name,
          jobTitle: contact.jobTitle,
          email: contact.email,
          mobile: contact.mobile,
          landline: contact.landline,
          preferredLanguage: contact.preferredLanguage
        });
      });

      // Add some additional random contacts for variety
      const additionalContacts = this.demoDataGenerator.generateAdditionalContacts(2);
      additionalContacts.forEach(contact => {
        this.addContact();
        const lastIndex = this.contactsFA.length - 1;
        this.contactsFA.at(lastIndex).patchValue({
          name: contact.name,
          jobTitle: contact.jobTitle,
          email: contact.email,
          mobile: contact.mobile,
          landline: contact.landline,
          preferredLanguage: contact.preferredLanguage
        });
      });

      // Update city options based on selected country
      this.filteredCityOptions = getCitiesByCountry(demoCompany.country);

      // Show success message with company name
      setTimeout(() => {
        this.msg.success(`Demo data loaded: ${demoCompany.name}`, { nzDuration: 3000 });
      }, 1000);

      // Log remaining companies for reference
      const remaining = this.demoDataGenerator.getRemainingCompaniesCount();
      console.log(`Demo data loaded for: ${demoCompany.name}`);
      console.log(`Remaining companies: ${remaining}`);

    } catch (error) {
      console.error('Error generating demo data:', error);
      this.msg.error('Failed to generate demo data. Please try again.');
    }
  }

  /**
   * Clears all contacts from the form
   */
  private clearAllContacts(): void {
    while (this.contactsFA.length !== 0) {
      this.contactsFA.removeAt(0);
    }
  }

  /**
   * Gets the current demo company info (for display)
   */
  getCurrentDemoCompany(): DemoCompany | null {
    return this.demoDataGenerator.getLastUsedCompany();
  }

  /**
   * Gets remaining demo companies count
   */
  getRemainingDemoCompanies(): number {
    return this.demoDataGenerator.getRemainingCompaniesCount();
  }

  /**
   * Resets the demo generator (clears used companies)
   */
  resetDemoGenerator(): void {
    this.demoDataGenerator.resetGenerator();
    this.msg.success('Demo generator reset. All companies available again!');
  }

  // ====== Auto Translation ======
  
  /**
   * Automatically translates English company name to Arabic
   * Triggered when English name field changes
   */
  onEnglishNameChange(englishName: string): void {
    if (!englishName || englishName.trim() === '') {
      return;
    }

    // Check if the name needs translation
    if (this.autoTranslate.needsTranslation(englishName)) {
      const arabicTranslation = this.autoTranslate.translateCompanyName(englishName);
      
      if (arabicTranslation && arabicTranslation !== englishName) {
        // Update the Arabic name field
        this.requestForm.patchValue({
          firstNameAR: arabicTranslation
        });
        
        // Silent translation - no notification needed
      }
    }
  }

  /**
   * Manually trigger translation (for button click)
   */
  translateToArabic(): void {
    const englishName = this.requestForm.get('firstName')?.value;
    
    if (!englishName || englishName.trim() === '') {
      this.msg.warning('Please enter an English company name first');
      return;
    }

    const arabicTranslation = this.autoTranslate.translateCompanyName(englishName);
    
    if (arabicTranslation && arabicTranslation !== englishName) {
      this.requestForm.patchValue({
        firstNameAR: arabicTranslation
      });
      
      // Silent translation - no notification needed
    } else {
      this.msg.warning('Unable to translate this name automatically');
    }
  }

  /**
   * Gets translation confidence for current names
   */
  getTranslationConfidence(): number {
    const englishName = this.requestForm.get('firstName')?.value;
    const arabicName = this.requestForm.get('firstNameAR')?.value;
    
    if (!englishName || !arabicName) return 0;
    
    return this.autoTranslate.getTranslationConfidence(englishName, arabicName);
  }

  /**
   * Gets alternative translations
   */
  getAlternativeTranslations(): string[] {
    const englishName = this.requestForm.get('firstName')?.value;
    
    if (!englishName) return [];
    
    return this.autoTranslate.getAlternativeTranslations(englishName);
  }

  // ====== Upload Document Modal ======
  
  /**
   * Opens the upload document modal
   */
  openUploadModal(): void {
    this.newDocument = {
      name: '',
      type: '',
      description: '',
      file: null
    };
    this.showUploadModal = true;
  }

  /**
   * Closes the upload document modal
   */
  closeUploadModal(): void {
    this.showUploadModal = false;
    this.newDocument = {
      name: '',
      type: '',
      description: '',
      file: null
    };
  }

  /**
   * Handles file selection
   */
  onFileSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
      this.newDocument.file = file;
      this.newDocument.name = file.name;
      
      // Auto-detect file type based on extension
      const extension = file.name.split('.').pop()?.toLowerCase();
      if (extension) {
        switch (extension) {
          case 'pdf':
            this.newDocument.type = 'Commercial Registration';
            break;
          case 'jpg':
          case 'jpeg':
          case 'png':
          case 'webp':
            this.newDocument.type = 'Tax Certificate';
            break;
          case 'doc':
          case 'docx':
            this.newDocument.type = 'License';
            break;
          default:
            this.newDocument.type = 'Other';
        }
      }
    }
  }

  /**
   * Saves the new document
   */
  saveNewDocument(): void {
    if (!this.newDocument.file) {
      this.msg.warning('Please select a file first');
      return;
    }

    if (!this.newDocument.type) {
      this.msg.warning('Please select a document type');
      return;
    }

    try {
      // Convert file to base64
      const reader = new FileReader();
      reader.onload = () => {
        const base64Content = reader.result as string;
        
        // إنشاء الـ document object بشكل صحيح
        const docData = {
          id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
          name: this.newDocument.name,
          type: this.newDocument.type,
          description: this.newDocument.description || '',
          size: this.newDocument.file.size,
          mime: this.newDocument.file.type,
          uploadedAt: new Date().toISOString(),
          contentBase64: base64Content
        };
        
        const docFormGroup = this.fb.group({
          id: [docData.id],
          name: [docData.name],
          type: [docData.type],
          description: [docData.description],
          size: [docData.size],
          mime: [docData.mime],
          uploadedAt: [docData.uploadedAt],
          contentBase64: [docData.contentBase64]
        });
        
        this.documentsFA.push(docFormGroup);

        this.msg.success('Document uploaded successfully');
        this.closeUploadModal();
      };
      
      reader.readAsDataURL(this.newDocument.file);
    } catch (error) {
      console.error('Error uploading document:', error);
      this.msg.error('Failed to upload document');
    }
  }

  // ====== Document Preview & Download (NEW) ======

  /**
   * Opens document preview modal
   */
  previewDocument(doc: any): void {
    const documentData = doc.value || doc;
    
    if (!documentData) {
      this.msg.error('Document data not found');
      return;
    }
    
    if (!documentData.contentBase64) {
      this.msg.error('Document content not available');
      return;
    }
    
    this.selectedDocument = documentData;
    this.showDocumentPreviewModal = true;
  }

  /**
   * Closes document preview modal
   */
  closeDocumentPreview(): void {
    this.showDocumentPreviewModal = false;
    this.selectedDocument = null;
  }

  /**
   * Downloads document - Fixed implementation
   */
  downloadDocument(doc: any): void {
    try {
      const docData = doc.value || doc;
      // Extract base64 content (remove data URL prefix if exists)
      let base64Content = docData.contentBase64 || '';
      
      // If it's a data URL, extract the base64 part
      if (base64Content.includes(',')) {
        base64Content = base64Content.split(',')[1];
      }
      
      // Convert base64 to blob
      const byteCharacters = atob(base64Content);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      const blob = new Blob([byteArray], { type: docData.mime || 'application/octet-stream' });
      
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = docData.name || 'document';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      this.msg.success('Document downloaded successfully');
    } catch (error) {
      console.error('Error downloading document:', error);
      this.msg.error('Failed to download document');
    }
  }

  /**
   * Gets preview URL for document
   */
  getPreviewUrl(doc: any): string {
    if (!doc || !doc.contentBase64) {
      return '';
    }
    
    if (doc.contentBase64.startsWith('data:')) {
      return doc.contentBase64;
    }
    
    return `data:${doc.mime || 'application/pdf'};base64,${doc.contentBase64}`;
  }

  /**
   * Gets safe preview URL for iframe (bypasses security)
   */
  getSafePreviewUrl(doc: any): SafeResourceUrl {
    const url = this.getPreviewUrl(doc);
    return this.sanitizer.bypassSecurityTrustResourceUrl(url);
  }

  /**
   * Checks if document can be previewed in browser
   */
  canPreview(doc: any): boolean {
    if (!doc) return false;
    const mime = doc.mime || '';
    return mime.includes('image') || mime.includes('pdf');
  }

  /**
   * Handles document click - preview for supported types, download for others
   */
  handleDocumentClick(doc: any): void {
    if (this.canPreview(doc)) {
      // Open preview for PDF and images
      this.previewDocument(doc);
    } else {
      // Direct download for Word, Excel, and other files
      this.downloadDocument(doc);
      this.msg.info('Downloading file... Preview not available for this file type.');
    }
  }

  /**
   * Format file size for display
   */
  formatFileSize(bytes: number): string {
    if (!bytes) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }

  /**
   * Enhanced helper methods for document type detection
   */
  isPdf(doc: any): boolean {
    if (!doc) return false;
    const mime = doc.mime || '';
    const name = doc.name || '';
    return mime.includes('pdf') || name.toLowerCase().endsWith('.pdf');
  }

  isImage(doc: any): boolean {
    if (!doc) return false;
    const mime = doc.mime || '';
    const name = doc.name || '';
    const result = mime.includes('image') || 
           name.toLowerCase().match(/\.(jpg|jpeg|png|gif|webp|bmp)$/);
    return !!result; // Force boolean instead of null
  }

  isWord(doc: any): boolean {
    if (!doc) return false;
    const mime = doc.mime || '';
    const name = doc.name || '';
    return mime.includes('word') || 
           mime.includes('document') || 
           mime.includes('officedocument') ||
           name.toLowerCase().match(/\.(doc|docx)$/);
  }

  isExcel(doc: any): boolean {
    if (!doc) return false;
    const mime = doc.mime || '';
    const name = doc.name || '';
    return mime.includes('excel') || 
           mime.includes('spreadsheet') ||
           name.toLowerCase().match(/\.(xls|xlsx)$/);
  }



  /**
   * Opens document in new tab - Simple solution (OLD - kept for compatibility)
   */
  downloadDoc(doc: any): void {
    try {
      // Simple solution - just open in new tab
      const dataUrl = `data:${doc.mime || 'application/pdf'};base64,${doc.contentBase64}`;
      window.open(dataUrl, '_blank');
    } catch (error) {
      console.error('Error opening document:', error);
      alert('Error opening document. Please try again.');
    }
  }

  /**
   * Check if user can manage documents (add/delete)
   */
  get canManageDocuments(): boolean {
    return this.userType === '1' && (this.editPressed || !this.hasRecord);
  }

  /**
   * Check if user is in view-only mode for documents
   */
  get isDocumentsViewOnly(): boolean {
    return this.userType === '2' || this.userType === '3';
  }

  /**
   * Gets documents count
   */
  getDocumentsCount(): number {
    if (this.documentsFA) {
      return this.documentsFA.length;
    }
    if (this.originalRecord?.documents) {
      return this.originalRecord.documents.length;
    }
    return 0;
  }

  /**
   * Gets documents list for display (extracts from FormArray)
   */
  getDocumentsList(): any[] {
    // Always extract from FormArray if it exists
    if (this.documentsFA && this.documentsFA.length > 0) {
      return this.documentsFA.controls.map(control => {
        // Get the raw value even if form is disabled
        const rawValue = control.getRawValue ? control.getRawValue() : control.value;
        return rawValue;
      });
    }
    // Fallback to original record documents
    if (this.originalRecord?.documents && Array.isArray(this.originalRecord.documents)) {
      return this.originalRecord.documents;
    }
    return [];
  }

  /**
   * Downloads document directly (handles both FormGroup and plain objects)
   */
  downloadDocumentDirect(doc: any): void {
    try {
      // Handle both FormGroup values and direct objects
      const docData = doc.value || doc;
      
      // Extract base64 content
      let base64Content = docData.contentBase64 || '';
      
      if (!base64Content) {
        this.msg.error('Document content not available');
        return;
      }
      
      // If it's a data URL, extract the base64 part
      if (base64Content.includes(',')) {
        base64Content = base64Content.split(',')[1];
      }
      
      // Convert base64 to blob
      const byteCharacters = atob(base64Content);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      const blob = new Blob([byteArray], { type: docData.mime || 'application/octet-stream' });
      
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = docData.name || 'document';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      this.msg.success('Document downloaded successfully');
    } catch (error) {
      console.error('Error downloading document:', error);
      this.msg.error('Failed to download document');
    }
  }
}